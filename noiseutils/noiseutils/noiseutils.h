// noiseutils.h
//
// Copyright (C) 2003-2005 Jason Bevins
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
// License (COPYING.txt) for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The developer's email is jlbezigvins@gmzigail.com (for great email, take
// off every 'zig').
//
// Updated for C++17 compatibility by TEK Nemesis and Grok on April 22, 2025.
// - Added support for std::filesystem and std::string_view for better cross-platform
//   compatibility and string handling efficiency.
// - Removed [[nodiscard]] from UnpackFloat, UnpackLittle16, and UnpackLittle32 to
//   resolve warnings about discarded return values.
// - Added noexcept to methods where appropriate for better exception safety.
// - Ensured Image class declarations match NoiseMap for consistent functionality.
// - Updated Image class to use std::vector instead of raw pointers for modern memory management.

#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <filesystem>

#include <noise/noisegen.h>
#include <noise/module/module.h>

namespace noise {

	namespace utils {

		/// @mainpage noiseutils
		///
		/// @section intro Introduction
		///
		/// This library contains useful classes for creating and rendering
		/// two-dimensional noise maps containing coherent noise that was
		/// generated from the libnoise library.  These classes are used to create
		/// procedural textures and terrain height maps.
		///
		/// noiseutils is known to compile under Windows 2000 Service Pack 4
		/// (using Microsoft Visual C++ 5.0) and under Gentoo Linux 10.0 (using
		/// gcc 3.3.4).  It should be portable across all platforms that can
		/// compile libnoise.
		///
		/// @section classes Classes
		///
		/// This library contains the following classes:
		/// - A <i>noise map</i> class: This class implements a two-dimensional
		///   array that stores floating-point values.  It's designed to store
		///   coherent-noise values generated by a noise module.
		/// - Several <i>noise-map builder</i> classes: Each of these classes
		///   fills a noise map with coherent-noise values generated by a noise
		///   module.  While filling a noise map, it iterates the coordinates of
		///   the input value along the surface of a specific mathematical object.
		///   Each of these classes implements a different mathematical object,
		///   such as a plane, a cylinder, or a sphere.
		/// - An <i>image</i> class: This class implements a two-dimensional array
		///   that stores color values.
		/// - Several <i>image-renderer</i> classes: these classes render images
		///   given the contents of a noise map.  Each of these classes renders an
		///   image in a different way.
		///
		/// @section contact Contact
		///
		/// Contact jas for questions about noiseutils.  The spam-resistant email
		/// address is jlbezigvins@gmzigail.com (For great email, take off every
		/// <a href=http://www.planettribes.com/allyourbased/story.shtml>zig</a>.)

		/// The maximum width of a raster.
		constexpr int RASTER_MAX_WIDTH = 32767;

		/// The maximum height of a raster.
		constexpr int RASTER_MAX_HEIGHT = 32767;

		// Unpacks a floating-point value into four bytes.  This function is
		// specific to Intel machines.  A portable version will come soon (I
		// hope.)
		// Remove [[nodiscard]] since return values are often discarded
		inline uint8* UnpackFloat(uint8* bytes, float value) noexcept {
			uint8* pBytes = reinterpret_cast<uint8*>(&value);
			bytes[0] = *pBytes++;
			bytes[1] = *pBytes++;
			bytes[2] = *pBytes++;
			bytes[3] = *pBytes++;
			return bytes;
		}

		// Unpacks a 16-bit integer value into two bytes in little endian format.
		// Remove [[nodiscard]] since return values are often discarded
		inline uint8* UnpackLittle16(uint8* bytes, uint16 integer) noexcept {
			bytes[0] = static_cast<uint8>((integer & 0x00ff));
			bytes[1] = static_cast<uint8>((integer & 0xff00) >> 8);
			return bytes;
		}

		// Unpacks a 32-bit integer value into four bytes in little endian format.
		// Remove [[nodiscard]] since return values are often discarded
		inline uint8* UnpackLittle32(uint8* bytes, uint32 integer) noexcept {
			bytes[0] = static_cast<uint8>((integer & 0x000000ff));
			bytes[1] = static_cast<uint8>((integer & 0x0000ff00) >> 8);
			bytes[2] = static_cast<uint8>((integer & 0x00ff0000) >> 16);
			bytes[3] = static_cast<uint8>((integer & 0xff000000) >> 24);
			return bytes;
		}

		template<typename T>
		[[nodiscard]] inline T ClampValue(T value, T lowerBound, T upperBound) noexcept {
			return std::clamp(value, lowerBound, upperBound);
		}

		[[nodiscard]] inline int GetMin(int a, int b) noexcept {
			return std::min(a, b);
		}

		[[nodiscard]] inline int GetMax(int a, int b) noexcept {
			return std::max(a, b);
		}

		/// Implements an exception class used by the noiseutils library.
		class ExceptionInvalidParam {};

		/// Implements an exception class used by the noiseutils library.
		class ExceptionOutOfMemory {};

		/// Implements an exception class used by the noiseutils library.
		class ExceptionUnknown {};

		/// The type of callback function used by noise map builders.
		typedef void (*NoiseMapCallback)(int row);

		/// Defines a color.
		///
		/// A color object contains four 8-bit channels: red, green, blue, and an
		/// alpha channel.  Channel values range from 0 to 255.
		///
		/// The alpha channel defines the transparency of the color.  If the alpha
		/// channel has a value of 0, the color is completely transparent.  If it
		/// has a value of 255, the color is completely opaque.
		struct Color {
			/// Constructor.
			Color() = default;

			/// Constructor.
			///
			/// @param r Value of red channel, from 0 to 255.
			/// @param g Value of green channel, from 0 to 255.
			/// @param b Value of blue channel, from 0 to 255.
			/// @param a Value of alpha channel, from 0 to 255.
			Color(uint8 r, uint8 g, uint8 b, uint8 a) noexcept :
				red(r),
				green(g),
				blue(b),
				alpha(a) {
			}

			/// Value of the alpha channel, from 0 to 255.
			uint8 alpha{};

			/// Value of the blue channel, from 0 to 255.
			uint8 blue{};

			/// Value of the green channel, from 0 to 255.
			uint8 green{};

			/// Value of the red channel, from 0 to 255.
			uint8 red{};
		};

		/// A single point in a gradient.
		struct GradientPoint {
			/// The position of this gradient point.
			double pos = 0.0;

			/// The color of this gradient point.
			Color color;
		};

		/// Defines a gradient that maps positions to colors.
///
/// A gradient-color object maps positions ranging from -1.0 to +1.0 to
/// colors that are linearly interpolated between gradient points.
		class GradientColor {
		public:
			/// Constructor.
			GradientColor() noexcept;

			/// Adds a gradient point to this gradient object.
			///
			/// @param gradientPos The position of this gradient point, from -1.0 to
			/// +1.0.
			/// @param gradientColor The color of this gradient point.
			///
			/// Gradient points are ordered by position in the gradient.  Gradient
			/// points must have unique positions; you cannot have two gradient points
			/// with the same position.
			///
			/// @throw noise::ExceptionInvalidParam A gradient point has the same
			/// position as another gradient point.
			void AddGradientPoint(double gradientPos, const Color& gradientColor);

			/// Deletes all gradient points from this gradient object.
			void Clear() noexcept;

			/// Returns the color at the specified position.
			///
			/// @param gradientPos The specified position, from -1.0 to +1.0.
			///
			/// @returns The color at that position.
			///
			/// @pre At least two gradient points have been added to this gradient
			/// object.
			const Color& GetColor(double gradientPos) const;

			/// Returns the number of gradient points.
			///
			/// @returns The number of gradient points.
			[[nodiscard]] int GetGradientPointCount() const noexcept {
				return m_gradientPointCount;
			}

		private:
			/// Returns the index of the insertion point for a new gradient point with
			/// the specified position.
			///
			/// @param gradientPos The position of the new gradient point.
			///
			/// @returns The insertion-point index.
			///
			/// @throw noise::ExceptionInvalidParam The specified position matches the
			/// position of an existing gradient point.
			int FindInsertionPos(double gradientPos);

			/// Inserts a gradient point at the specified insertion point.
			///
			/// @param insertionPos The zero-based index at which to insert the
			/// gradient point.
			/// @param gradientPos The position of the gradient point.
			/// @param gradientColor The color of the gradient point.
			void InsertAtPos(int insertionPos, double gradientPos,
				const Color& gradientColor);

			/// Number of gradient points.
			int m_gradientPointCount{};

			/// Array that stores the gradient points.
			std::unique_ptr<GradientPoint[]> m_pGradientPoints{};

			/// A working color used by the GetColor() method.
			mutable Color m_workingColor{};
		};

		/// Defines a two-dimensional array of floating-point values.
		class NoiseMap {
		public:
			/// Constructor.
			NoiseMap() noexcept;

			/// Constructor.
			///
			/// @param width The width of the noise map.
			/// @param height The height of the noise map.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			NoiseMap(int width, int height);

			/// Copy constructor.
			///
			/// @param rhs The noise map to copy.
			NoiseMap(const NoiseMap& rhs);

			/// Destructor.
			~NoiseMap() noexcept;

			/// Assignment operator.
			///
			/// @param rhs The noise map to assign.
			///
			/// @returns A reference to this noise map.
			NoiseMap& operator=(const NoiseMap& rhs);

			/// Clears the noise map to a specified value.
			///
			/// @param value The value that all positions within the noise map are
			/// cleared to.
			void Clear(float value) noexcept;

			/// Returns the value used for all positions outside of the noise map.
			///
			/// @returns The value used for all positions outside of the noise map.
			///
			/// All positions outside of the noise map are assumed to have a common
			/// value known as the <i>border value</i>.
			[[nodiscard]] float GetBorderValue() const noexcept {
				return m_borderValue;
			}

			/// Returns a const pointer to a slab.
			///
			/// @param row The row (or @a y coordinate) of the slab.
			///
			/// @returns A const pointer to a slab.
			///
			/// A slab is a row of values in the noise map.  The values in a slab
			/// have a constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] const float* GetConstSlabPtr(int row) const noexcept {
				return &m_values[static_cast<size_t>(row) * m_stride];
			}

			/// Returns a const pointer to a slab.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns A const pointer to a slab at the position (@a x, @a y).
			///
			/// A slab is a row of values in the noise map.  The values in a slab
			/// have a constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] const float* GetConstSlabPtr(int x, int y) const noexcept {
				return &m_values[static_cast<size_t>(y) * m_stride + x];
			}

			/// Returns the height of the noise map.
			///
			/// @returns The height of the noise map.
			[[nodiscard]] int GetHeight() const noexcept {
				return m_height;
			}

			/// Returns a pointer to a slab.
			///
			/// @param row The row (or @a y coordinate) of the slab.
			///
			/// @returns A pointer to a slab.
			///
			/// A slab is a row of values in the noise map.  The values in a slab
			/// have a constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] float* GetSlabPtr(int row) noexcept {
				return &m_values[static_cast<size_t>(row) * m_stride];
			}

			/// Returns a pointer to a slab.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns A pointer to a slab at the position (@a x, @a y).
			///
			/// A slab is a row of values in the noise map.  The values in a slab
			/// have a constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] float* GetSlabPtr(int x, int y) noexcept {
				return &m_values[static_cast<size_t>(y) * m_stride + x];
			}

			/// Returns the stride of the noise map.
			///
			/// @returns The stride of the noise map.
			///
			/// The stride is the offset between two values that have the same @a x
			/// coordinate but have @a y coordinates that differ by one.
			[[nodiscard]] int GetStride() const noexcept {
				return m_stride;
			}

			/// Returns the value at the specified position in the noise map.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns The value at that position.
			///
			/// This method returns the border value if the specified position lies
			/// outside of the noise map.
			float GetValue(int x, int y) const noexcept;

			/// Returns the width of the noise map.
			///
			/// @returns The width of the noise map.
			[[nodiscard]] int GetWidth() const noexcept {
				return m_width;
			}

			/// Reallocates the noise map to recover wasted memory.
			///
			/// @throw noise::ExceptionOutOfMemory Out of memory.
			///
			/// The contents of the noise map is unaffected.
			void ReclaimMem();

			/// Sets the value to use for all positions outside of the noise map.
			///
			/// @param borderValue The value to use for all positions outside of the
			/// noise map.
			///
			/// All positions outside of the noise map are assumed to have a common
			/// value known as the <i>border value</i>.
			void SetBorderValue(float borderValue) noexcept {
				m_borderValue = borderValue;
			}

			/// Sets the new size of the noise map.
			///
			/// @param width The new width of the noise map.
			/// @param height The new height of the noise map.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			/// @throw noise::ExceptionOutOfMemory Out of memory.
			///
			/// The width and height values must each be equal to or greater than zero,
			/// but not greater than noise::utils::RASTER_MAX_WIDTH or
			/// noise::utils::RASTER_MAX_HEIGHT.
			///
			/// The contents of the noise map are affected by this method.  If the
			/// noise map is made smaller, the contents are truncated; if the noise map
			/// is made larger, the new values are undefined.
			void SetSize(int width, int height);

			/// Sets the value at the specified position in the noise map.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			/// @param value The value to set at the given position.
			///
			/// This method does nothing if the specified position lies outside of the
			/// noise map.
			void SetValue(int x, int y, float value) noexcept;

			/// Takes ownership of the buffer from another noise map.
			///
			/// @param source The source noise map to move.
			///
			/// This method moves the buffer from the source noise map into this noise
			/// map.  After this method succeeds, the source noise map will be empty.
			void TakeOwnership(NoiseMap& source) noexcept;

		private:
			/// Returns the minimum amount of memory required to store a noise map of
			/// the specified size.
			///
			/// @param width The width of the noise map.
			/// @param height The height of the noise map.
			///
			/// @returns The minimum amount of memory required, in values.
			[[nodiscard]] static size_t CalcMinMemUsage(int width, int height) noexcept {
				return static_cast<size_t>(width) * height;
			}

			/// Calculates the stride for a noise map of the specified width.
			///
			/// @param width The width of the noise map.
			///
			/// @returns The stride.
			[[nodiscard]] static int CalcStride(int width) noexcept {
				return width;
			}

			/// The value used for all positions outside of the noise map.
			float m_borderValue{};

			/// The height of the noise map.
			int m_height{};

			/// The stride of the noise map.
			int m_stride{};

			/// The width of the noise map.
			int m_width{};

			/// The two-dimensional array of values.
			std::vector<float> m_values{};
		};

		/// Defines a two-dimensional array of colors.
		class Image {
		public:
			/// Default constructor for Image, initializes an empty image.
			/// Confidence: High - Matches NoiseMap's default constructor, which initializes an empty state.
			Image() noexcept {}

			/// Constructor.
			///
			/// @param width The width of the image.
			/// @param height The height of the image.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			Image(int width, int height);

			/// Copy constructor.
			///
			/// @param rhs The image to copy.

			Image(const Image& rhs);

			/// Destructor for Image, releases resources (vector handles its own cleanup).
			/// Confidence: High - Matches NoiseMap's destructor; std::vector handles cleanup automatically.
			~Image() noexcept {}

			/// Assignment operator.
			///
			/// @param rhs The image to assign.
			///
			/// @returns A reference to this image.
			Image& operator=(const Image& rhs);

			/// Clears the image to a specified color.
			///
			/// @param value The color that all positions within the image are cleared
			/// to.
			void Clear(const Color& value);

			/// Returns the color used for all positions outside of the image.
			///
			/// @returns The color used for all positions outside of the image.
			///
			/// All positions outside of the image are assumed to have a common color
			/// known as the <i>border color</i>.
			[[nodiscard]] Color GetBorderValue() const noexcept {
				return m_borderValue;
			}

			/// Returns a const pointer to a slab.
			///
			/// @param row The row (or @a y coordinate) of the slab.
			///
			/// @returns A const pointer to a slab.
			///
			/// A slab is a row of colors in the image.  The colors in a slab have a
			/// constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] const Color* GetConstSlabPtr(int row) const noexcept {
				return &m_values[static_cast<size_t>(row) * m_stride];
			}

			/// Returns a const pointer to a slab.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns A const pointer to a slab at the position (@a x, @a y).
			///
			/// A slab is a row of colors in the image.  The colors in a slab have a
			/// constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] const Color* GetConstSlabPtr(int x, int y) const noexcept {
				return &m_values[static_cast<size_t>(y) * m_stride + x];
			}

			/// Returns the height of the image.
			///
			/// @returns The height of the image.
			[[nodiscard]] int GetHeight() const noexcept {
				return m_height;
			}

			/// Returns a pointer to a slab.
			///
			/// @param row The row (or @a y coordinate) of the slab.
			///
			/// @returns A pointer to a slab.
			///
			/// A slab is a row of colors in the image.  The colors in a slab have a
			/// constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] Color* GetSlabPtr(int row) noexcept {
				return &m_values[static_cast<size_t>(row) * m_stride];
			}

			/// Returns a pointer to a slab.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns A pointer to a slab at the position (@a x, @a y).
			///
			/// A slab is a row of colors in the image.  The colors in a slab have a
			/// constant @a y coordinate and a varying @a x coordinate.
			[[nodiscard]] Color* GetSlabPtr(int x, int y) noexcept {
				return &m_values[static_cast<size_t>(y) * m_stride + x];
			}

			/// Returns the stride of the image.
			///
			/// @returns The stride of the image.
			///
			/// The stride is the offset between two colors that have the same @a x
			/// coordinate but have @a y coordinates that differ by one.
			[[nodiscard]] int GetStride() const noexcept {
				return m_stride;
			}

			/// Returns the color at the specified position in the image.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			///
			/// @returns The color at that position.
			///
			/// This method returns the border color if the specified position lies
			/// outside of the image.
			Color GetValue(int x, int y) const noexcept;

			/// Returns the width of the image.
			///
			/// @returns The width of the image.
			[[nodiscard]] int GetWidth() const noexcept {
				return m_width;
			}

			/// Reallocates the image to recover wasted memory.
			///
			/// @throw noise::ExceptionOutOfMemory Out of memory.
			///
			/// The contents of the image is unaffected.
			void ReclaimMem();

			/// Sets the color to use for all positions outside of the image.
			///
			/// @param borderValue The color to use for all positions outside of the
			/// image.
			///
			/// All positions outside of the image are assumed to have a common color
			/// known as the <i>border color</i>.
			void SetBorderValue(const Color& borderValue) noexcept {
				m_borderValue = borderValue;
			}

			/// Sets the new size of the image.
			///
			/// @param width The new width of the image.
			/// @param height The new height of the image.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			/// @throw noise::ExceptionOutOfMemory Out of memory.
			///
			/// The width and height values must each be equal to or greater than zero,
			/// but not greater than noise::utils::RASTER_MAX_WIDTH or
			/// noise::utils::RASTER_MAX_HEIGHT.
			///
			/// The contents of the image are affected by this method.  If the image
			/// is made smaller, the contents are truncated; if the image is made
			/// larger, the new colors are undefined.
			void SetSize(int width, int height);

			/// Sets the color at the specified position in the image.
			///
			/// @param x The @a x coordinate of the position.
			/// @param y The @a y coordinate of the position.
			/// @param value The color to set at the given position.
			///
			/// This method does nothing if the specified position lies outside of the
			/// image.
			void SetValue(int x, int y, const Color& value) noexcept;

			/// Takes ownership of the buffer from another image.
			///
			/// @param source The source image to move.
			///
			/// This method moves the buffer from the source image into this image.
			/// After this method succeeds, the source image will be empty.
			void TakeOwnership(Image& source) noexcept;

		private:
			/// Returns the minimum amount of memory required to store an image of the
			/// specified size.
			///
			/// @param width The width of the image.
			/// @param height The height of the image.
			///
			/// @returns The minimum amount of memory required, in colors.
			[[nodiscard]] static size_t CalcMinMemUsage(int width, int height) noexcept {
				return static_cast<size_t>(width) * height;
			}

			/// Calculates the stride for an image of the specified width.
			///
			/// @param width The width of the image.
			///
			/// @returns The stride.
			[[nodiscard]] static int CalcStride(int width) noexcept {
				return width;
			}

			/// The color used for all positions outside of the image.
			Color m_borderValue{};

			/// The height of the image.
			int m_height{};

			/// The stride of the image.
			int m_stride{};

			/// The width of the image.
			int m_width{};

			/// The two-dimensional array of colors.
			std::vector<Color> m_values{};
		};

		/// Abstract base class for a noise-map builder.
		///
		/// A builder class builds a noise map by filling it with coherent-noise
		/// values generated from the surface of a three-dimensional mathematical
		/// object.  Each builder class defines a specific three-dimensional surface,
		/// such as a cylinder, sphere, or plane.
		///
		/// To build a noise map, perform the following steps:
		/// - Pass a NoiseMap object to the SetDestNoiseMap() method.
		/// - Pass a noise module (derived from noise::module::Module) to the
		///   SetSourceModule() method.
		/// - Call the Build() method.
		class NoiseMapBuilder {
		public:
			/// Constructor.
			NoiseMapBuilder() noexcept;

			/// Destructor.
			virtual ~NoiseMapBuilder() = default;

			/// Builds the noise map.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			///
			/// Call this method after setting the source module and destination noise
			/// map.  After this method returns, the destination noise map will contain
			/// coherent-noise values generated from the source module.
			virtual void Build() = 0;

			/// Returns the height of the destination noise map.
			///
			/// @returns The height of the destination noise map, in points.
			///
			/// This value is set when the SetDestSize() method is called.
			[[nodiscard]] int GetDestHeight() const noexcept {
				return m_destHeight;
			}

			/// Returns the width of the destination noise map.
			///
			/// @returns The width of the destination noise map, in points.
			///
			/// This value is set when the SetDestSize() method is called.
			[[nodiscard]] int GetDestWidth() const noexcept {
				return m_destWidth;
			}

			/// Sets the callback function that Build() calls each time it fills a row
			/// of the noise map.
			///
			/// @param pCallback The callback function.
			///
			/// This callback function has a single integer parameter that contains a
			/// row number.  The Build() method calls this callback function each time
			/// it fills a row of the noise map.
			void SetCallback(NoiseMapCallback pCallback);

			/// Sets the destination noise map.
			///
			/// @param destNoiseMap The destination noise map.
			///
			/// The Build() method will write the generated coherent-noise values into
			/// this noise map.
			void SetDestNoiseMap(NoiseMap& destNoiseMap) noexcept {
				m_pDestNoiseMap = &destNoiseMap;
			}

			/// Sets the source module.
			///
			/// @param sourceModule The source module.
			///
			/// The Build() method generates coherent-noise values from this module and
			/// writes them into the destination noise map.
			void SetSourceModule(const noise::module::Module& sourceModule) noexcept {
				m_sourceModules = &sourceModule;
			}

			/// Sets the size of the destination noise map.
			///
			/// @param destWidth The width of the destination noise map, in points.
			/// @param destHeight The height of the destination noise map, in points.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			///
			/// This method does not actually set the size of the destination noise map
			/// until the Build() method is called.
			void SetDestSize(int destWidth, int destHeight);

		protected:
			/// The callback function that Build() calls each time it fills a row of
			/// the noise map.
			NoiseMapCallback m_pCallback{};

			/// The height of the destination noise map, in points.
			int m_destHeight{};

			/// The width of the destination noise map, in points.
			int m_destWidth{};

			/// The destination noise map that will contain the coherent-noise values.
			NoiseMap* m_pDestNoiseMap{};

			/// The source noise module that will generate the coherent-noise values.
			const noise::module::Module* m_sourceModules{};
		};

		/// Builds a cylindrical noise map.
		///
		/// This class builds a noise map by filling it with coherent-noise values
		/// generated from the surface of a cylinder.
		///
		/// This class describes these input values using an (angle, height)
		/// coordinate system.  After generating the coherent-noise value from the
		/// input value, it then "flattens" these coordinates onto a plane so that it
		/// can write the values into a two-dimensional noise map.
		///
		/// The cylinder model has a radius of 1.0 unit and has infinite height.  The
		/// cylinder is oriented along the @a y axis.  Its center is at the origin.
		///
		/// The @a x coordinate in the noise map represents the angle around the
		/// cylinder's @a y axis.  The @a y coordinate in the noise map represents
		/// the height above the @a x-z plane.
		///
		/// The application must also specify the lower and upper angle bounds of the
		/// noise map in degrees, as well as the lower and upper height bounds of the
		/// noise map.
		class NoiseMapBuilderCylinder : public NoiseMapBuilder {
		public:
			/// Constructor.
			NoiseMapBuilderCylinder() noexcept;

			void Build() override;

			/// Returns the lower angle boundary of the cylindrical noise map.
			///
			/// @returns The lower angle boundary, in degrees.
			[[nodiscard]] double GetLowerAngleBound() const noexcept {
				return m_lowerAngleBound;
			}

			/// Returns the lower height boundary of the cylindrical noise map.
			///
			/// @returns The lower height boundary.
			[[nodiscard]] double GetLowerHeightBound() const noexcept {
				return m_lowerHeightBound;
			}

			/// Returns the upper angle boundary of the cylindrical noise map.
			///
			/// @returns The upper angle boundary, in degrees.
			[[nodiscard]] double GetUpperAngleBound() const noexcept {
				return m_upperAngleBound;
			}

			/// Returns the upper height boundary of the cylindrical noise map.
			///
			/// @returns The upper height boundary.
			[[nodiscard]] double GetUpperHeightBound() const noexcept {
				return m_upperHeightBound;
			}

			/// Sets the coordinate boundaries of the noise map.
			///
			/// @param lowerAngleBound The lower angle boundary of the noise map, in
			/// degrees.
			/// @param upperAngleBound The upper angle boundary of the noise map, in
			/// degrees.
			/// @param lowerHeightBound The lower height boundary of the noise map.
			/// @param upperHeightBound The upper height boundary of the noise map.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			void SetBounds(double lowerAngleBound, double upperAngleBound,
				double lowerHeightBound, double upperHeightBound);

		private:
			/// Lower angle boundary of the cylindrical noise map, in degrees.
			double m_lowerAngleBound{};

			/// Lower height boundary of the cylindrical noise map.
			double m_lowerHeightBound{};

			/// Upper angle boundary of the cylindrical noise map, in degrees.
			double m_upperAngleBound{};

			/// Upper height boundary of the cylindrical noise map.
			double m_upperHeightBound{};
		};

		/// Builds a planar noise map.
		///
		/// This class builds a noise map by filling it with coherent-noise values
		/// generated from the surface of a plane.
		///
		/// This class describes these input values using an (x, z) coordinate
		/// system.  After generating the coherent-noise value from the input value,
		/// it then "flattens" these coordinates onto a plane so that it can write
		/// the values into a two-dimensional noise map.
		///
		/// The plane model is a flat square with sides of length 1.  It is oriented
		/// on the x-z plane, with its center at the origin.  The noise map's @a x
		/// coordinate corresponds to the plane's @a x coordinate, and the noise
		/// map's @a y coordinate corresponds to the plane's @a z coordinate.
		///
		/// The application must also specify the lower and upper @a x and @a z
		/// coordinate bounds of the noise map.
		class NoiseMapBuilderPlane : public NoiseMapBuilder {
		public:
			/// Constructor.
			NoiseMapBuilderPlane() noexcept;

			void Build() override;

			/// Enables or disables seamless tiling.
			///
			/// @param enable A flag that enables or disables seamless tiling.
			///
			/// Enabling seamless tiling builds a noise map with no seams at the
			/// edges.  This is accomplished by blending the noise map's edges together
			/// through linear interpolation.
			void EnableSeamless(bool enable = true) noexcept {
				m_isSeamlessEnabled = enable;
			}

			/// Returns the lower @a x boundary of the planar noise map.
			///
			/// @returns The lower @a x boundary of the noise map.
			[[nodiscard]] double GetLowerXBound() const noexcept {
				return m_lowerXBound;
			}

			/// Returns the lower @a z boundary of the planar noise map.
			///
			/// @returns The lower @a z boundary of the noise map.
			[[nodiscard]] double GetLowerZBound() const noexcept {
				return m_lowerZBound;
			}

			/// Returns the upper @a x boundary of the planar noise map.
			///
			/// @returns The upper @a x boundary of the noise map.
			[[nodiscard]] double GetUpperXBound() const noexcept {
				return m_upperXBound;
			}

			/// Returns the upper @a z boundary of the planar noise map.
			///
			/// @returns The upper @a z boundary of the noise map.
			[[nodiscard]] double GetUpperZBound() const noexcept {
				return m_upperZBound;
			}

			/// Determines if seamless tiling is enabled.
			///
			/// @returns
			/// - @a true if seamless tiling is enabled.
			/// - @a false if seamless tiling is disabled.
			[[nodiscard]] bool IsSeamlessEnabled() const noexcept {
				return m_isSeamlessEnabled;
			}

			/// Sets the boundaries of the planar noise map.
			///
			/// @param lowerXBound The lower @a x boundary of the noise map.
			/// @param upperXBound The upper @a x boundary of the noise map.
			/// @param lowerZBound The lower @a z boundary of the noise map.
			/// @param upperZBound The upper @a z boundary of the noise map.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			void SetBounds(double lowerXBound, double upperXBound,
				double lowerZBound, double upperZBound);

		private:
			/// A flag specifying whether seamless tiling is enabled.
			bool m_isSeamlessEnabled{};

			/// Lower @a x boundary of the planar noise map.
			double m_lowerXBound{};

			/// Lower @a z boundary of the planar noise map.
			double m_lowerZBound{};

			/// Upper @a x boundary of the planar noise map.
			double m_upperXBound{};

			/// Upper @a z boundary of the planar noise map.
			double m_upperZBound{};
		};

		/// Builds a spherical noise map.
		///
		/// This class builds a noise map by filling it with coherent-noise values
		/// generated from the surface of a sphere.
		///
		/// This class describes these input values using a (latitude, longitude)
		/// coordinate system.  After generating the coherent-noise value from the
		/// input value, it then "flattens" these coordinates onto a plane so that it
		/// can write the values into a two-dimensional noise map.
		///
		/// The sphere model has a radius of 1.0 unit.  Its center is at the origin.
		///
		/// The @a x coordinate in the noise map represents the longitude.  The @a y
		/// coordinate in the noise map represents the latitude.
		///
		/// The application must also specify the southern, northern, western, and
		/// eastern bounds of the noise map, in degrees.
		class NoiseMapBuilderSphere : public NoiseMapBuilder {
		public:
			/// Constructor.
			NoiseMapBuilderSphere() noexcept;

			void Build() override;

			/// Returns the eastern boundary of the spherical noise map.
			///
			/// @returns The eastern boundary of the noise map, in degrees.
			[[nodiscard]] double GetEastLonBound() const noexcept {
				return m_eastLonBound;
			}

			/// Returns the northern boundary of the spherical noise map.
			///
			/// @returns The northern boundary of the noise map, in degrees.
			[[nodiscard]] double GetNorthLatBound() const noexcept {
				return m_northLatBound;
			}

			/// Returns the southern boundary of the spherical noise map.
			///
			/// @returns The southern boundary of the noise map, in degrees.
			[[nodiscard]] double GetSouthLatBound() const noexcept {
				return m_southLatBound;
			}

			/// Returns the western boundary of the spherical noise map.
			///
			/// @returns The western boundary of the noise map, in degrees.
			[[nodiscard]] double GetWestLonBound() const noexcept {
				return m_westLonBound;
			}

			/// Sets the coordinate boundaries of the noise map.
			///
			/// @param southLatBound The southern boundary of the noise map, in
			/// degrees.
			/// @param northLatBound The northern boundary of the noise map, in
			/// degrees.
			/// @param westLonBound The western boundary of the noise map, in degrees.
			/// @param eastLonBound The eastern boundary of the noise map, in degrees.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			void SetBounds(double southLatBound, double northLatBound,
				double westLonBound, double eastLonBound);

		private:
			/// Eastern boundary of the spherical noise map, in degrees.
			double m_eastLonBound{};

			/// Northern boundary of the spherical noise map, in degrees.
			double m_northLatBound{};

			/// Southern boundary of the spherical noise map, in degrees.
			double m_southLatBound{};

			/// Western boundary of the spherical noise map, in degrees.
			double m_westLonBound{};
		};

		/// Renders an image from a noise map.
		///
		/// This class renders an image given the contents of a noise-map object.
		///
		/// To use this class, perform the following steps:
		/// - Pass a NoiseMap object to the SetSourceNoiseMap() method.
		/// - Pass an Image object to the SetDestImage() method.
		/// - Pass a GradientColor object to the AddGradientPoint() method one or
		///   more times (optional).
		/// - Call the Build() method.
		class RendererImage {
		public:
			/// Constructor.
			RendererImage() noexcept;

			/// Adds a gradient point to the gradient used by this renderer.
			///
			/// @param gradientPos The position of this gradient point.
			/// @param gradientColor The color of this gradient point.
			///
			/// @throw noise::ExceptionInvalidParam A gradient point has the same
			/// position as another gradient point.
			///
			/// This method adds a gradient point to the internal gradient object.
			///
			/// The gradient defines a color at specific positions ranging from -1.0
			/// to +1.0.  For any noise-map value, this class looks up the gradient
			/// color at that value and uses it to determine the color for the
			/// corresponding point in the image.
			///
			/// Before calling the Render() method, the application must specify at
			/// least two gradient points.
			void AddGradientPoint(double gradientPos, const Color& gradientColor);

			/// Builds a grayscale gradient.
			///
			/// This method builds a black-to-white gradient that is suitable for
			/// rendering grayscale images.
			///
			/// The Render() method uses this gradient if no gradient points were
			/// specified via the AddGradientPoint() method.
			void BuildGrayscaleGradient() noexcept;

			/// Builds a terrain-like gradient.
			///
			/// This method builds a terrain-like gradient that is suitable for
			/// rendering terrain height maps.
			///
			/// The Render() method uses this gradient if no gradient points were
			/// specified via the AddGradientPoint() method.
			void BuildTerrainGradient() noexcept;

			/// Clears the gradient.
			///
			/// This method removes all gradient points from the internal gradient
			/// object.
			void ClearGradient() noexcept;

			/// Enables or disables light shading.
			///
			/// @param enable A flag that enables or disables lighting.
			///
			/// If lighting is enabled, this class applies light shading to the points
			/// in the image based on the rate of change of the noise-map values.
			void EnableLight(bool enable = true) noexcept {
				m_isLightEnabled = enable;
			}

			/// Enables or disables noise-map wrapping.
			///
			/// @param enable A flag that enables or disables noise-map wrapping.
			///
			/// If wrapping is enabled, this class treats the noise map as if it were
			/// wrapped around a cylinder (for spherical noise maps) or a torus (for
			/// planar noise maps) when computing light shading.
			void EnableWrap(bool enable = true) noexcept {
				m_isWrapEnabled = enable;
			}

			/// Returns the azimuth of the light source, in degrees.
			///
			/// @returns The azimuth of the light source, in degrees.
			///
			/// The azimuth is the angle of the light source around the horizon, in
			/// degrees:
			/// - 0 degrees is north.
			/// - 90 degrees is east.
			/// - 180 degrees is south.
			/// - 270 degrees is west.
			[[nodiscard]] double GetLightAzimuth() const noexcept {
				return m_lightAzimuth;
			}

			/// Returns the brightness of the light source.
			///
			/// @returns The brightness of the light source.
			///
			/// A value of 0.0 represents a fully dark light source, and a value of
			/// 1.0 represents a fully bright light source.
			[[nodiscard]] double GetLightBrightness() const noexcept {
				return m_lightBrightness;
			}

			/// Returns the color of the light source.
			///
			/// @returns The color of the light source.
			[[nodiscard]] const Color& GetLightColor() const noexcept {
				return m_lightColor;
			}

			/// Returns the contrast of the light source.
			///
			/// @returns The contrast of the light source.
			///
			/// The contrast specifies how much the light source affects points in the
			/// image based on their elevation.  A contrast value of 0 disables the
			/// effect of elevation on lighting, and a contrast value of 1 applies the
			/// full effect of elevation on lighting.
			[[nodiscard]] double GetLightContrast() const noexcept {
				return m_lightContrast;
			}

			/// Returns the elevation of the light source, in degrees.
			///
			/// @returns The elevation of the light source, in degrees.
			///
			/// The elevation is the angle of the light source above the horizon, in
			/// degrees:
			/// - 0 degrees places the light source on the horizon.
			/// - 90 degrees places the light source directly overhead.
			[[nodiscard]] double GetLightElev() const noexcept {
				return m_lightElev;
			}

			/// Returns the intensity of the light source.
			///
			/// @returns The intensity of the light source.
			[[nodiscard]] double GetLightIntensity() const noexcept {
				return m_lightIntensity;
			}

			/// Determines if light shading is enabled.
			///
			/// @returns
			/// - @a true if lighting is enabled.
			/// - @a false if lighting is disabled.
			[[nodiscard]] bool IsLightEnabled() const noexcept {
				return m_isLightEnabled;
			}

			/// Determines if noise-map wrapping is enabled.
			///
			/// @returns
			/// - @a true if noise-map wrapping is enabled.
			/// - @a false if noise-map wrapping is disabled.
			[[nodiscard]] bool IsWrapEnabled() const noexcept {
				return m_isWrapEnabled;
			}

			/// Renders the destination image using the contents of the source noise
			/// map.
			///
			/// @pre SetSourceNoiseMap() has been previously called.
			/// @pre SetDestImage() has been previously called.
			/// @pre There are at least two gradient points in the gradient.  (Use
			/// AddGradientPoint() to add gradient points, or use
			/// BuildGrayscaleGradient() or BuildTerrainGradient() to build a default
			/// gradient.)
			/// @pre The width and height of the source noise map matches the width and
			/// height of the destination image.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			///
			/// This method renders the destination image using the contents of the
			/// source noise map.  If light shading is enabled, this method also
			/// applies light shading to the points in the destination image based on
			/// the rate of change of the noise-map values.
			void Render();

			/// Sets the azimuth of the light source, in degrees.
			///
			/// @param lightAzimuth The azimuth of the light source, in degrees.
			///
			/// The azimuth is the angle of the light source around the horizon, in
			/// degrees:
			/// - 0 degrees is north.
			/// - 90 degrees is east.
			/// - 180 degrees is south.
			/// - 270 degrees is west.
			void SetLightAzimuth(double lightAzimuth) noexcept {
				m_lightAzimuth = lightAzimuth;
				m_recalcLightValues = true;
			}

			/// Sets the brightness of the light source.
			///
			/// @param lightBrightness The brightness of the light source.
			///
			/// A value of 0.0 represents a fully dark light source, and a value of
			/// 1.0 represents a fully bright light source.
			void SetLightBrightness(double lightBrightness) noexcept {
				m_lightBrightness = lightBrightness;
				m_recalcLightValues = true;
			}

			/// Sets the color of the light source.
			///
			/// @param lightColor The color of the light source.
			void SetLightColor(const Color& lightColor) noexcept {
				m_lightColor = lightColor;
			}

			/// Sets the contrast of the light source.
			///
			/// @param lightContrast The contrast of the light source.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			///
			/// The contrast specifies how much the light source affects points in the
			/// image based on their elevation.  A contrast value of 0 disables the
			/// effect of elevation on lighting, and a contrast value of 1 applies the
			/// full effect of elevation on lighting.
			void SetLightContrast(double lightContrast);

			/// Sets the elevation of the light source, in degrees.
			///
			/// @param lightElev The elevation of the light source, in degrees.
			///
			/// The elevation is the angle of the light source above the horizon, in
			/// degrees:
			/// - 0 degrees places the light source on the horizon.
			/// - 90 degrees places the light source directly overhead.
			void SetLightElev(double lightElev) noexcept {
				m_lightElev = lightElev;
				m_recalcLightValues = true;
			}

			/// Sets the intensity of the light source.
			///
			/// @param lightIntensity The intensity of the light source.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			void SetLightIntensity(double lightIntensity);

			/// Sets the background image.
			///
			/// @param backgroundImage The background image.
			///
			/// The background image must exist throughout the lifetime of this object
			/// unless another image replaces that image.
			void SetBackgroundImage(const Image& backgroundImage) noexcept {
				m_pBackgroundImage = &backgroundImage;
			}

			/// Sets the destination image.
			///
			/// @param destImage The destination image.
			///
			/// The destination image must exist throughout the lifetime of this object
			/// unless another image replaces that image.
			void SetDestImage(Image& destImage) noexcept {
				m_pDestImage = &destImage;
			}

			/// Sets the source noise map.
			///
			/// @param sourceNoiseMap The source noise map.
			///
			/// The source noise map must exist throughout the lifetime of this object
			/// unless another noise map replaces that noise map.
			void SetSourceNoiseMap(const NoiseMap& sourceNoiseMap) noexcept {
				m_pSourceNoiseMap = &sourceNoiseMap;
			}

		private:
			/// Calculates the destination color.
			///
			/// @param sourceColor The source color generated from the noise-map value.
			/// @param backgroundColor The color from the background image at the
			/// corresponding position.
			/// @param lightValue The intensity of the light at the corresponding
			/// position.
			///
			/// @returns The destination color.
			Color CalcDestColor(const Color& sourceColor,
				const Color& backgroundColor, double lightValue) const noexcept;

			/// Calculates the intensity of the light given some elevation values.
			///
			/// @param center The noise-map value at the center position.
			/// @param left The noise-map value at the left position.
			/// @param right The noise-map value at the right position.
			/// @param down The noise-map value at the bottom position.
			/// @param up The noise-map value at the top position.
			///
			/// @returns The intensity of the light at the center position.
			double CalcLightIntensity(double center, double left, double right,
				double down, double up) const noexcept;

			/// The gradient that maps the noise-map values to colors.
			GradientColor m_gradient{};

			/// A flag specifying whether lighting is enabled.
			bool m_isLightEnabled{};

			/// A flag specifying whether wrapping is enabled.
			bool m_isWrapEnabled{};

			/// The azimuth of the light source, in degrees.
			double m_lightAzimuth{};

			/// The brightness of the light source.
			double m_lightBrightness{};

			/// The color of the light source.
			Color m_lightColor{};

			/// The contrast of the light source.
			mutable double m_lightContrast{};

			/// The elevation of the light source, in degrees.
			double m_lightElev{};

			/// The intensity of the light source.
			double m_lightIntensity{};

			/// The background image.
			const Image* m_pBackgroundImage{};

			/// The destination image.
			Image* m_pDestImage{};

			/// The source noise map.
			const NoiseMap* m_pSourceNoiseMap{};

			/// Used by the CalcLightIntensity() method to recalculate the light values
			/// only if necessary.
			mutable bool m_recalcLightValues{};

			/// The cosine of the azimuth of the light source.
			mutable double m_cosAzimuth{};

			/// The cosine of the elevation of the light source.
			mutable double m_cosElev{};

			/// The sine of the azimuth of the light source.
			mutable double m_sinAzimuth{};

			/// The sine of the elevation of the light source.
			mutable double m_sinElev{};
		};

		/// Renders a normal map from a noise map.
		///
		/// This class renders an image containing the normal vectors from a noise
		/// map.  These normal vectors can be used by a bump-mapping algorithm to
		/// shade a surface so that the noise map can act as a height map.
		///
		/// To use this class, perform the following steps:
		/// - Pass a NoiseMap object to the SetSourceNoiseMap() method.
		/// - Pass an Image object to the SetDestImage() method.
		/// - Call the Render() method.
		class RendererNormalMap {
		public:
			/// Constructor.
			RendererNormalMap() noexcept;

			/// Calculates the normal vector at a given point on the noise map.
			///
			/// @param nc The height of the given point in the noise map.
			/// @param nr The height of the left neighbor.
			/// @param nu The height of the up neighbor.
			/// @param bumpHeight The bump height.
			///
			/// @returns The normal vector represented as a color.
			///
			/// This method encodes the (x, y, z) components of the normal vector
			/// into the (red, green, blue) channels of the returned color.  In
			/// order to represent the vector as a color, each coordinate of the
			/// normal is mapped from the -1.0 to 1.0 range to the 0 to 255 range.
			Color CalcNormalColor(double nc, double nr, double nu,
				double bumpHeight) const noexcept;

			/// Enables or disables noise-map wrapping.
			///
			/// @param enable A flag that enables or disables noise-map wrapping.
			///
			/// If wrapping is enabled, this class treats the noise map as if it were
			/// wrapped around a cylinder (for spherical noise maps) or a torus (for
			/// planar noise maps) when computing the normal map.
			void EnableWrap(bool enable = true) noexcept;

			/// Returns the bump height for the normal map.
			///
			/// @returns The bump height.
			[[nodiscard]] double GetBumpHeight() const noexcept {
				return m_bumpHeight;
			}

			/// Renders the noise map to the destination image.
			///
			/// @pre SetSourceNoiseMap() has been previously called.
			/// @pre SetDestImage() has been previously called.
			///
			/// @throw noise::ExceptionInvalidParam An invalid parameter was specified;
			/// see the preconditions for more information.
			///
			/// This method encodes the (x, y, z) components of the normal vector
			/// into the (red, green, blue) channels of the image.  In order to
			/// represent the vector as a color, each coordinate of the normal is
			/// mapped from the -1.0 to 1.0 range to the 0 to 255 range.
			///
			/// The alpha channel of the image is set to 0 for all points.
			void Render();

			/// Sets the bump height for the normal map.
			///
			/// @param bumpHeight The bump height.
			void SetBumpHeight(double bumpHeight) noexcept;

			/// Sets the destination image.
			///
			/// @param destImage The destination image.
			///
			/// The destination image must exist throughout the lifetime of this
			/// object unless another image replaces that image.
			void SetDestImage(Image& destImage) noexcept;

			/// Sets the source noise map.
			///
			/// @param sourceNoiseMap The source noise map.
			///
			/// The destination image must exist throughout the lifetime of this
			/// object unless another image replaces that image.
			void SetSourceNoiseMap(const NoiseMap& sourceNoiseMap) noexcept;

		private:
			/// The bump height for the normal map.
			double m_bumpHeight{};

			/// A flag specifying whether wrapping is enabled.
			bool m_isWrapEnabled{};

			/// A pointer to the destination image.
			Image* m_pDestImage{};

			/// A pointer to the source noise map.
			const NoiseMap* m_pSourceNoiseMap{};
		};

		/// Abstract base class for a noise-map writer.
		class Writer {
		public:
			/// Constructor.
			Writer() = default;

			/// Destructor.
			virtual ~Writer() = default;

			/// Returns the name of the file to write.
			///
			/// @returns The name of the file to write.
			[[nodiscard]] const std::filesystem::path& GetDestFilename() const noexcept {
				return m_destFilename;
			}

			/// Sets the name of the file to write.
			///
			/// @param destFilename The name of the file to write.
			// Use string_view for efficiency and add noexcept
			void SetDestFilename(std::string_view destFilename) noexcept {
				m_destFilename = std::filesystem::path(destFilename);
			}

			/// Writes the contents to the file.
			virtual void WriteDestFile() = 0;

		protected:
			// Update m_destFilename to use filesystem::path for cross-platform compatibility
			/// The name of the file to write.
			std::filesystem::path m_destFilename{};
		};

		/// Writes a noise map to a Windows bitmap (BMP) file.
		class WriterBMP : public Writer {
		public:
			/// Sets the source image.
			///
			/// @param sourceImage The source image.
			///
			/// The source image must exist throughout the lifetime of this object
			/// unless another image replaces that image.
			void SetSourceImage(const Image& sourceImage) noexcept {
				m_pSourceImage = &sourceImage;
			}

			void WriteDestFile() override;

		private:
			/// Calculates the width of one horizontal line in the file, in bytes.
			///
			/// @param width The width of the image, in points.
			///
			/// @returns The width of one horizontal line in the file.
			///
			/// Windows bitmap files require that the width of one horizontal line is
			/// a multiple of four.
			[[nodiscard]] int CalcWidthByteCount(int width) const noexcept;

			/// The source image.
			const Image* m_pSourceImage{};
		};

		/// Writes a noise map to a Terragen terrain (TER) file.
		class WriterTER : public Writer {
		public:
			/// Constructor.
			WriterTER() noexcept : m_metersPerPoint(1.0) {
			}

			/// Returns the number of meters per point.
			///
			/// @returns The number of meters per point.
			[[nodiscard]] double GetMetersPerPoint() const noexcept {
				return m_metersPerPoint;
			}

			/// Sets the number of meters per point.
			///
			/// @param metersPerPoint The number of meters per point.
			void SetMetersPerPoint(double metersPerPoint) noexcept {
				m_metersPerPoint = metersPerPoint;
			}

			/// Sets the source noise map.
			///
			/// @param sourceNoiseMap The source noise map.
			///
			/// The source noise map must exist throughout the lifetime of this object
			/// unless another noise map replaces that noise map.
			void SetSourceNoiseMap(const NoiseMap& sourceNoiseMap) noexcept {
				m_pSourceNoiseMap = &sourceNoiseMap;
			}

			void WriteDestFile() override;

		private:
			/// Calculates the width of one horizontal line in the file, in bytes.
			///
			/// @param width The width of the noise map, in points.
			///
			/// @returns The width of one horizontal line in the file.
			[[nodiscard]] int CalcWidthByteCount(int width) const noexcept;

			/// The number of meters per point.
			double m_metersPerPoint{};

			/// The source noise map.
			const NoiseMap* m_pSourceNoiseMap{};
		};

	} // namespace utils

} // namespace noise